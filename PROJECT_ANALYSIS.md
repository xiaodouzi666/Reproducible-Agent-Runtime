# RAR (Reproducible Agent Runtime): 面向AI4S的可复现多智能体系统设计与实现

---

## 摘要

随着人工智能在科学研究领域的广泛应用，AI for Science (AI4S) 的可复现性问题日益凸显。本文提出了 RAR (Reproducible Agent Runtime) 系统——一个面向科学计算场景的可复现多智能体运行时框架。该系统融合了 BDI（Belief-Desire-Intention）认知架构、Contract Net 协议、ACL（Agent Communication Language）消息协议等经典理论框架，通过完整的执行追踪、可复现的运行机制和可审计的证据链，构建了值得信赖的 AI 科学计算框架。本文详细阐述了 RAR 系统的设计原理、技术实现、构建挑战以及实践价值，为 AI4S 领域的可复现性问题提供了一个可行的解决方案。

**关键词**：多智能体系统、可复现性、AI for Science、BDI架构、证据链、审计机制

---

## 第一章 引言

### 1.1 研究背景

人工智能技术在科学研究领域的应用日益广泛，从药物发现到材料科学，从生物信息学到气候建模，AI 正在重塑科学研究的范式。然而，伴随着 AI4S 的快速发展，一个严峻的问题逐渐浮出水面——**可复现性危机**。

当前 AI for Science 领域面临的核心挑战包括：

- **黑箱问题**：AI 模型的决策过程缺乏透明度，难以追溯推理路径
- **结果不可复现**：相同任务在不同运行中可能产生不同结果，缺乏确定性保证
- **证据链断裂**：科学结论与原始数据、文献之间的联系不清晰
- **协作难以审计**：多智能体协作过程中的决策无法被有效审查

### 1.2 研究动机与目标

科学研究的核心价值在于可复现性和可证伪性。然而，LLM 的概率特性、复杂的多智能体交互以及缺乏统一的证据表示，使得传统 AI 系统的可复现性难以保证。

RAR 系统旨在解决上述问题，其核心目标包括：

1. **完全透明的执行追踪**：记录系统运行的每一个步骤
2. **可复现的运行机制**：通过确定性算法和缓存机制保证结果可复现
3. **可审计的证据链**：建立结论与源材料之间的明确联系
4. **灵活的配置模式**：支持不同场景下的成本-质量权衡

### 1.3 论文结构

本文共分为七章，结构如下：

- **第一章**：引言，阐述研究背景、动机和目标
- **第二章**：理论基础，介绍系统所融合的经典理论框架
- **第三章**：系统架构，详细描述 RAR 的分层设计和各层实现
- **第四章**：关键技术与实现，深入探讨核心模块的技术细节
- **第五章**：构建挑战与解决方案，分析开发过程中的技术难点
- **第六章**：实践价值与反思，总结项目带来的收获与启示
- **第七章**：结论与展望，总结全文并展望未来工作

---

## 第二章 理论基础

### 2.1 BDI（Belief-Desire-Intention）认知架构

BDI 架构源自认知科学领域，由 Bratman 等学者提出，用于建模理性智能体的决策过程。该架构将智能体的认知状态分为三个层次：

```
Beliefs（信念）  →  智能体对世界状态的认识
Desires（欲望）  →  智能体希望达成的目标
Intentions（意图） →  智能体承诺执行的计划
```

在 RAR 系统中，BDI 架构被用于建模每个智能体的决策过程。当智能体的信念发生变化时，系统自动触发追踪记录，将状态变化持久化，确保后续审计时能够完整重现智能体的决策过程。

### 2.2 Contract Net 协议

Contract Net 协议是 FIPA（Foundation for Intelligent Physical Agents）标准化的多智能体任务分配协议。该协议模拟现实中的招标-投标-中标过程，包含以下阶段：

```
1. CFP (Call for Proposals) - 招标阶段
2. BID - 投标阶段
3. EVALUATION - 评标阶段
4. AWARD - 授予合同
5. REPORT - 结果报告
```

RAR 系统采用 Contract Net 协议实现智能体间的任务分配，通过多维度评估（成本、延迟、成功概率、能力匹配）选择最优执行者。

### 2.3 ACL（Agent Communication Language）消息协议

ACL 协议基于言语行为理论（Speech Act Theory），将智能体之间的通信视为一种言语行为。协议定义了多种言语行为类型，按功能分类：

| 类别 | 言语行为 |
|------|----------|
| 信息类 | INFORM、CONFIRM、DISCONFIRM |
| 指令类 | REQUEST、QUERY |
| 承诺类 | PROPOSE、COMMIT、ACCEPT、REJECT |
| Contract Net | CFP、BID、AWARD |
| 审计类 | CHALLENGE、RETRACT、JUSTIFY |

### 2.4 Dung 论证框架

Dung 论证框架是处理冲突观点的形式化论证理论。RAR 系统在最高级模式（OWL Full）中引入了论证图生成机制，采用 claim-support-attack 结构表示论证关系，使科学结论的推理过程更加透明和可审查。

---

## 第三章 系统架构

### 3.1 整体架构设计

RAR 系统采用分层架构设计，遵循"关注点分离"原则，每一层专注于特定的功能职责。从下至上依次为：追踪层、工具层、协议层、智能体层、编排层和界面层。

```
┌─────────────────────────────────────────────────────────────────┐
│                    第六章 用户界面层                              │
│                   Streamlit UI / CLI                           │
├─────────────────────────────────────────────────────────────────┤
│                    第五章 编排层                                 │
│                   Orchestrator (核心引擎)                       │
├─────────────────────────────────────────────────────────────────┤
│                    第四章 智能体层                               │
│  ┌──────────────┐ ┌──────────────┐ ┌──────────────┐ ┌─────────┐│
│  │   Planner    │ │  Researcher  │ │   Executor   │ │ Auditor ││
│  │  (规划智能体) │ │ (研究智能体)  │ │  (执行智能体) │ │(审计智能体)││
│  └──────────────┘ └──────────────┘ └──────────────┘ └─────────┘│
├─────────────────────────────────────────────────────────────────┤
│                    第三章 协议层                                 │
│  ┌──────────────────┐  ┌──────────────────────────────────┐    │
│  │  Contract Net    │  │      ACL 消息协议                │    │
│  │ (任务招标机制)    │  │  (CFP/BID/AWARD/INFORM/CHALLENGE)│    │
│  └──────────────────┘  └──────────────────────────────────┘    │
├─────────────────────────────────────────────────────────────────┤
│                    第二章 工具层                                 │
│  ┌──────────────────┐      ┌──────────────────┐                 │
│  │  LocalSearchTool │      │  PythonExecTool  │                 │
│  │  (BM25全文搜索)  │      │  (沙箱代码执行)   │                 │
│  └──────────────────┘      └──────────────────┘                 │
├─────────────────────────────────────────────────────────────────┤
│                    第一章 追踪层                                 │
│  ┌─────────────┐  ┌─────────────┐  ┌────────────────────────┐   │
│  │   Tracer    │  │ TraceStore  │  │   EvidenceAnchor        │   │
│  │ (追踪API)   │  │ (JSONL存储) │  │   (证据锚点系统)        │   │
│  └─────────────┘  └─────────────┘  └────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

### 3.2 追踪层（Trace Layer）

追踪层是 RAR 系统的核心基础设施，负责记录所有执行细节，确保完全的可追溯性和可复现性。

#### 3.2.1 TraceEntry 数据结构

每个追踪条目记录一个执行事件的完整信息，包含以下维度：

| 维度 | 包含字段 |
|------|----------|
| 标识信息 | run_id、step_id、timestamp |
| 事件类型 | agent_start、tool_call、message_sent、llm_call 等 |
| 智能体信息 | agent_id、agent_role、BDI 状态 |
| 通信信息 | performative、sender、receiver、message_id |
| 工具信息 | tool_name、tool_input、tool_output、latency_ms |
| LLM 信息 | model、thinking_level、cache_key、response_hash |
| 证据信息 | evidence_anchors 列表 |
| 可复现性信息 | input_hash、output_hash、deterministic |

#### 3.2.2 JSONL 存储格式

追踪日志采用 JSONL（JSON Lines）格式存储，具有增量写入、流式处理、可扩展、可压缩等优势。

### 3.3 工具层（Tool Layer）

#### 3.3.1 LocalSearchTool - BM25 全文搜索

采用 BM25（Best Matching 25）算法进行全文检索：

```
BM25(D,Q) = Σ IDF(qi) × (f(qi,D) × (k1 + 1)) / (f(qi,D) + k1 × (1 - b + b × |D| / avgdl))
```

#### 3.3.2 PythonExecTool - 沙箱执行环境

安全执行机制包括：受限全局命名空间、预加载科学计算库、排除危险模块、输出重定向捕获、Seed 固定确保可复现性。

### 3.4 协议层（Protocol Layer）

#### 3.4.1 ACL 消息结构

```python
@dataclass
class ACLMessage:
    performative: Performative      # 言语行为类型
    sender: str                     # 发送者标识
    receiver: str                   # 接收者标识
    content: Any                    # 消息内容
    message_id: str                 # 唯一消息标识符
    conversation_id: str            # 会话标识符
    reply_to: Optional[str]         # 被回复消息标识符
    protocol: Optional[str]         # 协议类型
    evidence: List[EvidenceAnchor]  # 证据锚点列表
    artifacts: List[str]            # 产物列表
```

#### 3.4.2 Contract Net 状态机与投标评估

协议为每个任务维护状态机：`ANNOUNCED → BIDDING → AWARDED → IN_PROGRESS → COMPLETED/FAILED`。

综合分数计算公式：

```
score = success_probability × 0.4 +
         capability_match × 0.3 +
         (1 / (1 + estimated_cost)) × 0.15 +
         (1 / (1 + estimated_latency)) × 0.15
```

### 3.5 智能体层（Agent Layer）

智能体层基于 BDI 架构实现四种专门化智能体：

| 智能体 | 职责 |
|--------|------|
| PlannerAgent | 任务分解、子任务分配、结果综合、重新规划 |
| ResearcherAgent | BM25 搜索、证据锚点生成、相关性过滤 |
| ExecutorAgent | 沙箱代码执行、变量提取、图表保存、输出捕获 |
| AuditorAgent | 多层次审计策略、多维度质量检查、挑战生成 |

### 3.6 编排层（Orchestrator Layer）

编排层是系统的核心引擎，协调整个运行流程。函数调用循环通过 LLM 驱动工具调用，持续运行直到 finalize 或达到最大步数。

每个运行具有明确的生命周期状态：`PENDING → RUNNING → COMPLETED/COMPLETED_WITH_WARNINGS/FAILED`

### 3.7 用户界面层（UI Layer）

提供命令行接口和 Web 界面两种交互方式。

---

## 第四章 关键技术与实现

### 4.1 LLM 集成层

#### 4.1.1 Gemini 客户端封装

系统封装了 Google Gemini API，提供确定性缓存、自动降级和结构化输出功能。

**确定性缓存机制**：对请求载荷标准化后计算 SHA256 哈希作为缓存键，执行请求前先查询缓存。

**自动降级策略**：

```python
try:
    return call_gemini_pro(request)
except TransientError:
    logger.warning("Pro model failed, falling back to Flash")
    return call_gemini_flash(request)
```

**结构化输出**：将 Pydantic 模型转换为 JSON Schema，传递给 Gemini API，验证失败时构建修复提示并重试。

#### 4.1.2 函数调用设计

| 工具 | 输入 | 输出 | 证据支持 |
|------|------|------|----------|
| research | query, num_results | findings, anchors | ✓ |
| execute | code, seed | output, variables, figures | ✓ |
| audit | subtask_result | passed, challenges | ✓ |
| finalize | answer | summary, answer | ✓ |

### 4.2 可复现性保证机制

#### 4.2.1 多层次确定性保证

| 层次 | 机制 |
|------|------|
| 随机数生成 | 固定 numpy 和 random 的 seed |
| 搜索算法 | BM25 结果确定性排序 |
| LLM 调用 | 基于哈希的缓存机制 |
| 工具执行 | 输入输出哈希验证 |
| 日志记录 | JSONL 追去追加写入 |

#### 4.2.2 重放引擎与差异分析

重放流程：加载原始运行元数据 → 配置对齐 → 缓存复用 → 执行重放 → 结果比较。

差异分析包括：答案匹配、步骤差异、成本差异、缓存命中率。

### 4.3 证据锚点系统

```python
@dataclass
class EvidenceAnchor:
    doc_id: str              # 文档唯一标识
    doc_title: str           # 文档标题
    location: str            # 精确位置描述
    content_hash: str        # 内容哈希（MD5/SHA）
    content_snippet: str     # 内容片段
    relevance_score: float   # 相关性分数
```

内容哈希确保证据的可验证性，通过 SHA256 计算并验证完整性。

### 4.4 配置系统

#### 4.4.1 三级运行模式

| 模式 | 模型 | 思考级别 | 审计级别 | 证据要求 | 适用场景 |
|------|------|----------|----------|----------|----------|
| OWL Lite | Flash | minimal | light | 1个锚点，分数>0.15 | 快速探索 |
| OWL DL | Pro | high | strict | 2个锚点，分数>0.30 | 生产环境 |
| OWL Full | Pro | high | argumentation | 3个锚点，分数>0.35，论证图 | 最高可靠性 |

#### 4.4.2 多维度审计检查

成功状态、证据数量、证据结构、相关性、运行时错误、单位一致性六维度检查。

---

## 第五章 构建挑战与解决方案

### 5.1 技术挑战

#### 5.1.1 确定性与可复现性

**核心挑战**：LLM 的概率特性、多智能体并发交互、工具执行随机因素。

**解决方案**：全局 Seed 管理、LLM 响应缓存（基于请求载荷的确定性哈希）、确定性算法（BM25）、输出哈希验证、JSONL 追加写入。

#### 5.1.2 状态一致性

**解决方案**：采用顺序执行模型避免并发状态更新问题，所有状态变化记录到 JSONL，每个 TraceEntry 包含完整快照。

#### 5.1.3 证据链完整性

**解决方案**：严格证据锚点结构（文档 ID、标题、位置、哈希、片段），MD5/SHA 哈希计算，相关性分数过滤。

### 5.2 设计挑战

#### 5.2.1 复杂度与可理解性

**解决方案**：详细追踪日志、Streamlit UI 可视化、预生成示例运行、分层架构、渐进式模式。

#### 5.2.2 性能与资源消耗

**解决方案**：JSONL 增量写入、LLM 响应缓存、模式分级、产物分离。

#### 5.2.3 LLM 集成不确定性

**解决方案**：自动降级策略（Pro → Flash）、Schema 重试机制、优雅降级、丰富错误处理。

### 5.3 工程挑战

#### 5.3.1 错误处理与降级

**"finalize-first" 不变式**：最终确认是硬性门限，论证图生成等附加功能是 best-effort。

**状态码**：completed、completed_with_warnings、failed、waiting。

#### 5.3.2 测试与验证

**解决方案**：预生成示例运行、固定 Seed 测试、模块化设计、Mock 机制。

---

## 第六章 实践价值与反思

### 6.1 理论知识深化

通过实际实现 BDI 架构，理解了如何将抽象的认知科学理论转化为可运行的代码。状态追踪机制使得智能体的决策过程完全透明，比传统的"黑箱"AI 系统更具可解释性。

Contract Net 协议展示了公平、高效的任务分配机制设计，ACL 消息协议体现了言语行为理论在实际系统中的应用。

### 6.2 工程实践技能

| 特性 | 应用 |
|------|------|
| dataclass | 定义不可变数据结构，减少样板代码 |
| Enum | 类型安全的状态管理 |
| ABC | 定义和强制接口契约 |
| contextlib | 输出重定向和资源管理 |

六层架构设计展示了分层架构的威力，依赖注入、策略模式、工厂模式等设计模式得到充分应用。

数据持久化方面，JSONL 格式支持增量写入、流式处理、可扩展、可压缩；内容寻址存储支持去重和验证；元数据分离使各文件职责清晰。

### 6.3 跨学科知识融合

| 领域 | 获得的知识 |
|------|-----------|
| 认知科学 | BDI 架构将理性智能体模型转化为可运行代码 |
| 语言哲学 | 言语行为理论为通信提供形式化语义框架 |
| 博弈论 | Contract Net 协议展示拍卖机制在任务分配中的应用 |
| 证据理论 | 证据锚点和哈希验证体现证据理论的严谨性 |
| 科学哲学 | 可复现性和证伪主义是科学研究的核心原则 |

### 6.4 软件工程思维

**可复现性工程**：所有随机源可配置 seed，所有输入输出被记录，模型版本和参数被追踪。

**渐进式增强**：owl_lite/owl_dl/owl_full 设计允许用户根据需求选择合适模式，论证图生成等附加功能设计为 best-effort。

**错误处理哲学**：LLM 不可用时回退到规则规划，每种状态都有明确定义，错误信息包含上下文和建议。

---

## 第七章 结论与展望

### 7.1 研究总结

RAR 项目是一个理论与实践深度结合的复杂系统，具有以下特点：

1. **解决了实际问题**：针对 AI4S 领域的可复现性危机
2. **融合了多个理论**：BDI、Contract Net、ACL、Dung 论证框架
3. **工程实现优秀**：清晰的架构、完整的追踪、灵活的配置
4. **学习价值极高**：涵盖多智能体系统、LLM 工程、分布式系统等领域

项目的创新之处：

| 创新点 | 描述 |
|--------|------|
| 完整性 | 从 BDI 架构到 Contract Net 协议，从证据链到论证图 |
| 可复现性 | Seed 固定、LLM 缓存、确定性算法等多重机制 |
| 透明性 | 完整的追踪记录使每个决策步骤都可追溯 |
| 灵活性 | 三级模式设计允许成本和可靠性权衡 |

### 7.2 贡献与意义

**学术贡献**：提出了面向 AI4S 的可复现多智能体系统框架，实现了完整的证据锚点系统，设计了多层次的审计机制，提供了可复现性的工程实践范式。

**实践意义**：为科学计算场景提供了可信的 AI 辅助工具，为多智能体系统的可观测性设计提供了参考，为 LLM 应用工程化提供了实践经验。

### 7.3 未来工作

**功能扩展**：分布式执行、更多科学计算工具集成、交互式论证图可视化、多格式结果导出。

**性能优化**：增量追踪、基于语义相似度的智能缓存、大规模数据流式处理。

**生态建设**：插件系统支持第三方扩展、推动可复现 AI 系统标准化、建立开源社区。

### 7.4 结语

RAR 项目为 AI for Science 领域的可复现性问题提供了一个可行的解决方案。通过融合认知科学、语言哲学、博弈论等多个领域的理论，结合软件工程的最佳实践，我们构建了一个可信赖、可复现、可审计的 AI 系统框架。

这个项目不仅解决了实际问题，更重要的是展示了如何构建一个负责任的 AI 系统——一个能够解释自己的决策过程、能够被审计和验证、能够产生可靠结果的系统。这正是未来 AI for Science 领域所需要的核心能力。

```
Transparency + Reproducibility + Auditability = Trustworthy AI4S
```

---

## 附录

### A. 系统目录结构

```
RAR/
├── src/
│   ├── agents/           # 智能体实现
│   ├── protocols/        # 协议实现
│   ├── tools/            # 工具实现
│   ├── tracing/          # 追踪系统
│   ├── llm/              # LLM 集成
│   └── orchestrator.py   # 编排器
├── corpus/               # 本地语料库
├── runs/                 # 运行数据
├── ui/                   # 用户界面
├── tests/                # 测试代码
├── DESIGN.md             # 设计文档
└── README.md             # 使用指南
```

### B. 配置文件示例

```yaml
# run_spec.yaml
task_description: "分析量子计算在密码学中的应用"
mode: "owl_dl"
model: "gemini-3-pro-preview"
thinking_level: "high"
seed: 42
corpus_path: "./corpus"
max_steps: 20
```

### C. 追踪条目示例

```json
{
  "run_id": "run_20250109_120000",
  "step_id": 5,
  "timestamp": "2025-01-09T12:00:15.123Z",
  "event_type": "llm_call",
  "agent_id": "planner_001",
  "agent_role": "planner",
  "model": "gemini-3-pro-preview",
  "thinking_level": "high",
  "cache_key": "abc123...",
  "response_hash": "def456...",
  "deterministic": true
}
```

---

**文档版本**: v1.0
**最后更新**: 2025-01-09
**作者**: RAR 项目团队
